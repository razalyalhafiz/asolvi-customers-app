'use strict';
var util = require('util');
var spawn = require('child_process').spawn;
var Promise = require('bluebird');
var readline = require('readline');
var fs = require('fs');
var request = require('request');
var path = require('path');
var log = require('noogger');
Promise.config({ warnings: true, longStackTraces: true })

class Tester {
  runDocker(samplePath, webAppURL) {
    log.notice("============ STEP 2 ============");
    log.notice("Running QS (Docker here)");

    var dockerRun = () => {
      return _createDockerExecFile(samplePath)
        .then(() => _runDockerFile(samplePath));
    };

    var waitWebApp = (docker) => {
      return _waitForIt(webAppURL, 300)
        .catch((err) => {
          docker.kill();
          log.info("Timeout reached. Killing docker run process.");
          throw err;
        });
    }

    return dockerRun()
      .then((docker) => waitWebApp(docker));
  }

  runTests(webAppURL, userEmail, userPassword) {
    return new Promise(function (resolve, reject) {
      log.notice("============ STEP 3 ============");
      log.notice("Testing QS (Boo! here)");

      const cmd = spawn("casperjs", ["test", "--fail-fast", "--verbose", "./casper/webapp-login-test.js",
        "--username=" + userEmail, "--password=" + userPassword, "--initial-url=" + webAppURL],
        { cwd: __dirname });
      cmd.stdout.on('data', (data) => process.stdout.write(data.toString()));
      cmd.stderr.on('data', (data) => log.error(data.toString()));
      cmd.on('exit', function (code) {
        if (code !== 0) {
          log.error("Step failed with code: " + code);
          return reject(new Error("Running WebApp UI Tests exited with code: " + code));
        }
        return resolve();
      });
    });
  }

  stopDocker() {
    return _stopRunningQS();
  }
}

//Recreate the exec.sh file without -it flags
//PRE CONDITION: Last command must be "docker exec/run"
function _createDockerExecFile(workingDir) {
  return new Promise(function (resolve, reject) {
    var output = fs.createWriteStream(path.join(workingDir, 'docker.sh'));
    var rl = readline.createInterface({
      input: fs.createReadStream(path.join(workingDir, 'exec.sh'))
    });
    rl.on('line', function (line) {
      if (line.startsWith("docker run") && line.indexOf(" -it") > 0) {
        line = line.replace(" -it", "");
      }
      output.write(line + "\n");
    });
    rl.on('close', function () {
      output.end();
      return resolve();
    });
  });
}

//Run each docker command in sequence
function _runDockerFile(workingDir) {
  return new Promise(function (resolve, reject) {
    const cmd = spawn("sh", ["docker.sh"], {
      cwd: workingDir,
      detached: true
    });
    cmd.stdout.on('data', (data) => process.stdout.write(data.toString()));
    cmd.stderr.on('data', (data) => process.stderr.write(data.toString()));
    cmd.on('exit', (code) => {
      if (code !== 0 && code !== 137) { //137 = SIGKILL
        log.error("Docker run exit with code: " + code);
        return reject(new Error("Docker quitted with code: " + code));
      }
    });
    setTimeout(function () {
      //Because a Promise can't be resolved and rejected at the same time
      //Give some time to reject on docker errors if this is the last command
      return resolve(cmd);
    }, 3000);
  });
}

// //Read a exec.sh file and extract lines as docker commands
// //PRE CONDITION: Last command must be "docker exec/run"
// function _parseDockerExecFile(workingDir) {
//   return new Promise(function(resolve, reject){
//     var rl = readline.createInterface({
//       input: fs.createReadStream(path.join(workingDir, 'exec.sh'))
//     });
//     var dockerCommands = [];
//     rl.on('line', function (line) {
//       if (line.startsWith("docker")){
//         dockerCommands.push(line);
//       }
//     });
//     rl.on('close', function(){
//       resolve(dockerCommands);
//     })
//   });
// }

// //Run each docker command in sequence
// function _runDockerCommands(workingDir, commands) {
//   var spawns = [];
//   //Create a promise for a Spawn execution for each line
//   commands.forEach(function(line, idx){
//     spawns.push(new Promise(function(resolve, reject){
//       var args = line.split(" ");
//       args = args.splice(1, args.length);
//       //Remove -it from the arguments, if present
//       var whitelistedArgs = [];
//       args.forEach(function(v){
//         if (v !== "-it" && v !== "-ti"){
//           whitelistedArgs.push(v);
//         }
//       });
//       const cmd = spawn("docker", whitelistedArgs, {
//         cwd: workingDir,
//         detached: true
//       });
//       cmd.stdout.on('data', (data) => process.stdout.write(data.toString()));
//       cmd.stderr.on('data', (data) => process.stderr.write(data.toString()));
//       cmd.on('exit', (code) => {
//         if (code !== 0 && code !== 137){ //137 = SIGKILL
//           //log.error("Docker run exit with code: " + code);
//           cmd.kill();
//           console.log("####### ##### Killing this command instance");
//           return reject(new Error("Docker quitted with code: " + code));
//         }
//         // return resolve(cmd);
//       });
//
//       // if(idx+1===commands.length){
//         setTimeout(function(){
//           //Because a Promise can't be resolved and rejected at the same time
//           //Give some time to reject on docker errors if this is the last command
//           console.log("####### ##### Resolving this command instance");
//           return resolve(cmd);
//         }, 3000);
//       // }
//     }));
//   });
//   //Run each line
//   return Promise.mapSeries(spawns, function(val, idx){
//     console.log("Command #" + (idx+1) + " run");
//   })
//     .catch((err) => Promise.reject(err))
//     .then((cmds) => Promise.resolve(cmds[spawns.length-1]));
// }


//Stop ALL running Docker Containers
function _stopRunningQS() {
  return new Promise(function (resolve, reject) {
    log.info("STOPPING all running Docker containers.");
    var cmd = spawn("docker", ["rm", "-f", "$(docker ps -a -q)"], { shell: '/bin/bash' });
    cmd.stdout.on('data', (data) => {
      log.debug(data.toString());
    });
    cmd.stderr.on('data', (data) => {
      log.warning(data.toString());
    });
    cmd.on('exit', function (code) {
      return resolve();
    });
  });
}

//Wait for a URL to respond a "positive" http code.
function _waitForIt(url, timeout) {
  log.info(util.format("Waiting up to %s seconds for the WebApp to run at %s", timeout, url))
  return new Promise(function (resolve, reject) {
    var ellapsed = 0;
    var loop = setInterval(() => {
      request.get(url, {
        timeout: 500
      })
        .on('error', (err) => {
          //ignored
        })
        .on('response', (response) => {
          if (response.statusCode >= 200 && response.statusCode < 400) {
            clearInterval(loop);
            log.debug(util.format("App is up!! Took %s seconds to run.", ellapsed));
            return resolve(ellapsed);
          }
        });

      if (ellapsed >= timeout) {
        clearInterval(loop);
        return reject(new Error(util.format("Timeout reached. Waited %s for seconds before failing.", ellapsed)));
      }
      ellapsed += 1;
    }, 1000);
  });
}
module.exports = Tester;
